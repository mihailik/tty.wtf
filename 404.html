<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TTY</title>
<style>
html {
  box-sizing: border-box;
  width: 100%; height: 100%;
  overflow: hidden;
  padding: 0; margin: 0;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  width: 100%; height: 100%;
  overflow: hidden;
  padding: 0; margin: 0;
}
*, *:before, *:after {
  box-sizing: inherit;
}

#toolbar {
  position: absolute;
  top: 0; left: 0; width: 100%;
  background-image: linear-gradient(to top, #fff6f6, white 1em);
  border-bottom: solid 1px #ffe6e6;
  padding-left: 0.3em;
  white-space: nowrap;
  overflow-x: auto;
}

#toolbar button {
  width: 2.7em;
  height: 2.7em;
  margin: 0.15em;
  border-radius: 0.5em;
  background: white;
  border: solid 1px #d6d6d6;
  box-shadow: 2px 3px 6px rgb(0, 0, 0, 0.09);
}

#toolbar button.pressed {
  background: gray;
  color: white;
}

#textarea {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  overflow: auto;
  border: none;
  padding: 1em;
  outline: none;
  font: inherit;
  padding-top: 4em;
  resize: none;
}

</style>
</head>
<body>
<textarea id="textarea" autofocus>
</textarea>
<div id="toolbar">
<button id="bold">ğ—•</button>
<button id="italic">ğ˜</button>
<button id="fractur">ğ•±</button>
<button id="cursive">ğ“’</button>
<button id="upper">áµ</button>
<button id="squareBox">ğŸ…‚</button>
<button id="squareFill">ğŸ†€</button>
<button id="round">â“‡</button>
<button id="typewrighter">ğšƒ</button>
<button id="wide">ğ•</button>

<div id="status" style="
  position: absolute;
  right: 1em;
  top: 0;"></div>
</div>
<script>
// @ts-check

function ttywtf() {

  var REGEX_anychar_unicode = /./ug;
  var REGEX_startsWithBold = /^bold/;

  var variants = {
    bold: {AZ:'ğ—”ğ—•ğ—–ğ——ğ—˜ğ—™ğ—šğ—›ğ—œğ—ğ—ğ—Ÿğ— ğ—¡ğ—¢ğ—£ğ—¤ğ—¥ğ—¦ğ—§ğ—¨ğ—©ğ—ªğ—«ğ—¬ğ—­', az:'ğ—®ğ—¯ğ—°ğ—±ğ—²ğ—³ğ—´ğ—µğ—¶ğ—·ğ—¸ğ—¹ğ—ºğ—»ğ—¼ğ—½ğ—¾ğ—¿ğ˜€ğ˜ğ˜‚ğ˜ƒğ˜„ğ˜…ğ˜†ğ˜‡', '09':'ğŸ¬ğŸ­ğŸ®ğŸ¯ğŸ°ğŸ±ğŸ²ğŸ³ğŸ´ğŸµ'},
    italic: {AZ:'ğ˜ˆğ˜‰ğ˜Šğ˜‹ğ˜Œğ˜ğ˜ğ˜ğ˜ğ˜‘ğ˜’ğ˜“ğ˜”ğ˜•ğ˜–ğ˜—ğ˜˜ğ˜™ğ˜šğ˜›ğ˜œğ˜ğ˜ğ˜Ÿğ˜ ğ˜¡', az:'ğ˜¢ğ˜£ğ˜¤ğ˜¥ğ˜¦ğ˜§ğ˜¨ğ˜©ğ˜ªğ˜«ğ˜¬ğ˜­ğ˜®ğ˜¯ğ˜°ğ˜±ğ˜²ğ˜³ğ˜´ğ˜µğ˜¶ğ˜·ğ˜¸ğ˜¹ğ˜ºğ˜»'},
    bolditalic: {AZ:'ğ˜¼ğ˜½ğ˜¾ğ˜¿ğ™€ğ™ğ™‚ğ™ƒğ™„ğ™…ğ™†ğ™‡ğ™ˆğ™‰ğ™Šğ™‹ğ™Œğ™ğ™ğ™ğ™ğ™‘ğ™’ğ™“ğ™”ğ™•', az:'ğ™–ğ™—ğ™˜ğ™™ğ™šğ™›ğ™œğ™ğ™ğ™Ÿğ™ ğ™¡ğ™¢ğ™£ğ™¤ğ™¥ğ™¦ğ™§ğ™¨ğ™©ğ™ªğ™«ğ™¬ğ™­ğ™®ğ™¯'},
    fractur: {AB:'ğ”„ğ”…', C:'â„­',DG:'ğ”‡ğ”ˆğ”‰ğ”Š', HI:'â„Œâ„‘', JQ:'ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””', R:'â„œ', SY:'ğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œ', Z:'â„¨', az:'ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·'},
    boldfractur: {AZ:'ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…', az:'ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ'},
    cursive: {AZ:'ğ’œğµğ’ğ’Ÿğ¸ğ¹ğ’¢ğ»ğ¼ğ’¥ğ’¦ğ¿ğ‘€ğ’©ğ’ªğ’«ğ’¬ğ‘…ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ', az:'ğ’¶ğ’·ğ’¸ğ’¹ğ‘’ğ’»ğ‘”ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒğ‘œğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“'},
    boldcursive: {AZ:'ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©', az:'ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ'},
    upper: {AP:'á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾', Q:'á´¼Ì´', RW:'á´¿Ë¢áµ€áµâ±½áµ‚', ap:'áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–', q:'Ù©', rz: 'Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»', '09': 'â°Â¹Â²Â³â´âµâ¶â·â¸â¹'},
    squareBox: {AZ:'ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰'},
    squareFill: {AP:'ğŸ…°ğŸ…±ğŸ…²ğŸ…³ğŸ…´ğŸ…µğŸ…¶ğŸ…·ğŸ…¸ğŸ…¹ğŸ…ºğŸ…»ğŸ…¼ğŸ…½ğŸ…¾ğŸ…¿ğŸ†€ğŸ†ğŸ†‚ğŸ†ƒğŸ†„ğŸ†…ğŸ††ğŸ†‡ğŸ†ˆğŸ†‰'},
    round: {AZ:'â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“â“', az:'â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“â“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©', '09':'â“ªâ‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨'},
    typewriter: {AZ:'ğ™°ğ™±ğ™²ğ™³ğ™´ğ™µğ™¶ğ™·ğ™¸ğ™¹ğ™ºğ™»ğ™¼ğ™½ğ™¾ğ™¿ğš€ğšğš‚ğšƒğš„ğš…ğš†ğš‡ğšˆğš‰', az:'ğšŠğš‹ğšŒğšğšğšğšğš‘ğš’ğš“ğš”ğš•ğš–ğš—ğš˜ğš™ğššğš›ğšœğšğšğšŸğš ğš¡ğš¢ğš£', '09': 'ğŸ¶ğŸ·ğŸ¸ğŸ¹ğŸºğŸ»ğŸ¼ğŸ½ğŸ¾ğŸ¿'},
    wide: {AZ:'ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤', az:'ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«', '09': 'ğŸ˜ğŸ™ğŸšğŸ›ğŸœğŸğŸğŸŸğŸ ğŸ¡'}
  };

  var parseRanges = createParser();

  var save_timeout;
  var selection_timeout_slide;
  var selection_timeout_max;

  var textareaKeyEventTimestamp = 0;
  var textareaLastValue = '';

  var textarea = /** @type {HTMLTextAreaElement} */(document.getElementById('textarea'));
  textarea.value = getStorageText();

  var status = document.getElementById('status');

  var textareaMouseDown = false;
  textarea.onchange = textarea_onchange;
  textarea.onselect = textarea_onselectionchange;
  textarea.onselectionchange = textarea_onselectionchange;
  textarea.onselectstart = textarea_onselectionchange;
  textarea.onkeydown = textarea_onkeydown;
  textarea.onkeyup = textarea_onkeyevent;
  textarea.onkeypress = textarea_onkeyevent;
  textarea.onmousedown = textarea_onmousedown;
  textarea.onmouseup = textarea_onmouseup;
  textarea.onmousemove = textarea_onmousemove;

  window.onunload = window_onunload;

  addButtonHandlers();
  textarea_onselectionchange();

  function addButtonHandlers() {
    var buttonsArray = document.getElementsByTagName('button');
    for (var i = 0; i < buttonsArray.length; i++) {
      addHandler(buttonsArray[i]);
    }

    function addHandler(btn) {
      btn.onmousedown = btn_onmousedown;
      btn.onmouseup = btn_mouseup;
      btn.onclick = btn_click;

      function btn_onmousedown(evt) {
        if (evt.preventDefault) evt.preventDefault();
        if (evt.stopPropagation) evt.stopPropagation();
        if ('cancelBubble' in evt) evt.cancelBubble = true;

        var modifier = btn.id;
        var remove = (btn.className || '').indexOf('pressed') >=0;
        applyModifierToSelection(modifier, remove);
      }

      /**
       * @param evt {MouseEvent}
       **/
      function btn_mouseup(evt) {
        if (evt.preventDefault) evt.preventDefault();
        if (evt.stopPropagation) evt.stopPropagation();
        if ('cancelBubble' in evt) evt.cancelBubble = true;
      }

      /**
       * @param evt {MouseEvent}
       **/
      function btn_click(evt) {
        if (evt.preventDefault) evt.preventDefault();
        if (evt.stopPropagation) evt.stopPropagation();
        if ('cancelBubble' in evt) evt.cancelBubble = true;
      }
    }
  }

  /**
   * @param modifier {string}
   * @param remove {boolean=}
   **/
  function applyModifierToSelection(modifier, remove) {
    var oldText = textarea.value;

    if (!modifier || !oldText) return;

    var leadText = oldText.slice(0, textarea.selectionStart);
    var modifyText = oldText.slice(textarea.selectionStart, textarea.selectionEnd);
    var trailText = oldText.slice(textarea.selectionEnd);

    if (!modifyText) return;

    var newText = leadText + applyModifier(
      modifyText,
      modifier,
      remove) + trailText;

    if (oldText !== newText) {
      // ensure this update is not considered a user edit
      textareaCurrentValue = newText;

      textarea.value = newText;
      if (textarea.selectionStart !== leadText.length) textarea.selectionStart = leadText.length;
      if (textarea.selectionEnd !== newText.length - trailText.length) textarea.selectionEnd = newText.length - trailText.length;
    }
  }

  function getStorageText() {
    try {
      return localStorage.getItem('tty.wtf.content');
    } catch (error) {
      console.log('Browser failed to get data from localStorage. ', error);
    }
  }

  function setStorageText(text) {
    try {
      localStorage.setItem('tty.wtf.content', text);
      /** @type {{lastStorageSuccess?: boolean}}*/(setStorageText).lastStorageSuccess = true;
    } catch (error) {
      if (/** @type {{lastStorageSuccess?: boolean}}*/(setStorageText).lastStorageSuccess !== true)
        console.log('Browser failed to store data into localStorage. ', error);
      /** @type {{lastStorageSuccess?: boolean}}*/(setStorageText).lastStorageSuccess = false;
    }
  }

  function textarea_onchange() {
    var textareaCurrentValue = textarea.value;
    if (textareaCurrentValue === textareaLastValue) {
      textarea_onselectionchange();
    } else {
      var timestamp = Date.now();
      var shortlyAfterKeydown = (Date.now() - textareaKeyEventTimestamp) < 50;
      var formattingApplied = false;
      if (textareaCurrentValue && shortlyAfterKeydown) {
        if (textarea.selectionStart === textarea.selectionEnd) {
          var leadLength = Math.max(0, textarea.selectionStart - 10);
          var trailLength = Math.max(0, textareaCurrentValue.length - textarea.selectionStart - 2);

          if (textareaCurrentValue.slice(0, leadLength) === textareaLastValue.slice(0, leadLength)
             && textareaCurrentValue.slice(-trailLength) === textareaLastValue.slice(-trailLength)) {
            // change is close to the cursor, good

            // find where change starts exactly
            while (leadLength + trailLength < textareaCurrentValue.length
                  && leadLength + trailLength < textareaLastValue.length
                  && textareaCurrentValue.charCodeAt(leadLength) === textareaLastValue.charCodeAt(leadLength)) {
              leadLength++;
            }

            // find where change ends exactly
            while (leadLength + trailLength < textareaCurrentValue.length
                  && leadLength + trailLength < textareaLastValue.length
                  && textareaCurrentValue.charCodeAt(textareaCurrentValue.length - trailLength) === textareaLastValue.charCodeAt(textareaLastValue.length - trailLength)) {
              trailLength++;
            }

            // will be applying modifiers one by one, more important last
            var modifiersChange = getModifiersTextSection(
              textareaLastValue,
              leadLength,
              textareaLastValue.length - trailLength
            ).parsed.modifiers;

            var modifiersLead = textareaLastValue.length === leadLength + trailLength ?
              [] :
              getModifiersTextSection(
                textareaLastValue,
                leadLength,
                leadLength + 2
              ).parsed.modifiers;

            if (modifiersChange.length) {
              var applyModifiers = modifiersLead.slice().reverse();
              for (var i = 0; i < modifiersChange.length; i++) {
                var mod = modifiersChange[i];
                if (applyModifiers.indexOf(mod)<0) applyModifiers.unshift(mod);
              }

              var innerText = textareaCurrentValue.slice(leadLength, -trailLength);
              for (var i = 0; i < applyModifiers.length; i++) {
                innerText = applyModifier(innerText, applyModifiers[i]);
              }

              var prevInnerText = textareaLastValue.slice(leadLength, -trailLength);
              var editedInnerText = textareaCurrentValue.slice(leadLength, -trailLength);

              var newText =
                textareaCurrentValue.slice(0, leadLength) +
                innerText +
                textareaCurrentValue.slice(-trailLength);

              var retainSelectionStart = textarea.selectionStart;
              textareaLastValue = newText;
              textarea.value = newText;
              formattingApplied = true;
              if (textarea.selectionStart !== retainSelectionStart) textarea.selectionStart = retainSelectionStart;
              if (textarea.selectionEnd !== retainSelectionStart) textarea.selectionEnd = retainSelectionStart;

              console.log(
                {
                  from: prevInnerText,
                  edited: editedInnerText,
                  formatted: innerText,
                  mods: applyModifiers
                }
              );
            }
          }
        }
      }

      if (!formattingApplied) {
        textareaLastValue = textareaCurrentValue;
      }

      clearTimeout(save_timeout);
      save_timeout = setTimeout(textarea_onchange_debounced, 600);
    }
  }

  function textarea_onchange_debounced() {
    setStorageText(textarea.value);
    textarea_onselectionchange_debounced();
  }

  function textarea_onmousedown() {
    textareaMouseDown = true;
    textarea_onselectionchange();
  }

  function textarea_onmouseup() {
    textareaMouseDown = false;
    textarea_onselectionchange();
  }

  function textarea_onmousemove() {
    if (!textareaMouseDown) return;
    textarea_onselectionchange();
  }

  function textarea_onkeydown(e) {
    if (e.metaKey || e.ctrlKey) {
      var letter = String.fromCharCode(e.keyCode);
      var modifier =
        letter === 'B' ? 'bold' :
        letter === 'I' ? 'italic' :
        '';

      if (modifier) {
        var btn = document.getElementById(modifier);
        if (btn) {
          var remove = (btn.className || '').indexOf('pressed') >=0;
          applyModifierToSelection(modifier, remove);
        }
      }
    }

    textarea_onkeyevent();
  }

  function textarea_onkeyevent(e) {
    textareaKeyEventTimestamp = Date.now();
    textarea_onchange();
  }

  function textarea_onselectionchange() {
    if (!selection_timeout_max) selection_timeout_max = setTimeout(textarea_onselectionchange_debounced, 200);
    clearTimeout(selection_timeout_slide);
    selection_timeout_slide = setTimeout(textarea_onselectionchange_debounced, 70);
  }

  function textarea_onselectionchange_debounced() {
    clearTimeout(selection_timeout_slide);
    clearTimeout(selection_timeout_max);
    selection_timeout_max = 0;

    status.textContent = status.innerText = textarea.selectionStart + ':' + (textarea.selectionEnd - textarea.selectionStart);
    var modTextSection = getModifiersTextSection(textarea.value, textarea.selectionStart, textarea.selectionEnd);
    console.log('modTextSection: ', modTextSection);

    var toggleButtons = document.querySelectorAll('#toolbar button');
    for (var i = 0; i < toggleButtons.length; i++) {
      var btn = /** @type {HTMLButtonElement} */(toggleButtons[i]);
      if (btn.id) {
        var pressed = modTextSection.parsed.modifiers.indexOf(btn.id) >= 0;
        if (pressed) btn.className = (btn.className || '').replace(/\s+$/, '') + ' pressed';
        else btn.className = btn.className.replace(/\s*\bpressed\b\s*/, ' ') ;
      }
    }
  }

  function getModifiersTextSection(text, start, end) {
    var modText = text;
    if (start !== end) {
      modText = modText.slice(start, end);
      return { text: modText, start: start, end: end, parsed: parseRanges(modText) };
    }

    var consequentMatch = /\S*$/.exec(text.slice(0, start));
    var consequentEntryStart = start - (consequentMatch ? consequentMatch[0].length : 0);
    var parsed = consequentMatch && consequentMatch[0] && parseRanges(consequentMatch[0]);
    var consequentEntry = parsed && parsed.length && parsed[parsed.length -1];
    if (!consequentMatch || !consequentMatch[0]) {
      consequentMatch = /^\S*/.exec(text.slice(start));
      parsed = consequentMatch && parseRanges(consequentMatch[0]);
      consequentEntry = parsed && parsed.length && parsed[0];
    }

    if (consequentMatch && consequentMatch[0]) {
      if (consequentEntry) {
        parsed.length = 1;
        parsed.modifiers = typeof consequentEntry === 'string' ? [] : consequentEntry.modifiers;
        parsed.fullModifiers = typeof consequentEntry === 'string' ? '' : consequentEntry.fullModifiers;
        parsed[0] = consequentEntry;
      } else {
        parsed.length = 0;
        parsed.modifiers = [];
        parsed.fullModifiers = '';
      }

      return {
        text: typeof consequentEntry === 'string' ? consequentEntry : consequentEntry.uni,
        start: consequentEntryStart,
        end: consequentEntryStart + consequentEntry.length,
        parsed: parsed
      };
    }

    return { text: '', start: start, end: start, parsed: parseRanges('')};
  }

  function window_onunload() {
    // save to local storage NOW
    textarea_onchange_debounced();
  }

  /**
   * @param text {string}
   * @param modifier {string}
   * @param remove {boolean}
   **/
  function applyModifier(text, modifier, remove) {
    var parsed = parseRanges(text, { disableCoalescing: true });
    var text = '';

    for (var iRange = 0; iRange < parsed.length; iRange++) {
      var range = parsed[iRange];

      if (typeof range === 'string') {
        if (remove) {
          text += range;
        } else {
          var rangeMap = variants[modifier];
          if (!rangeMap) {
            // strange modifier???
            text += range;
          } else {
            for (var iChar = 0; iChar < range.length; iChar++) {
              // range is an ASCII string, iterate for each character
              var ch = range.charAt(iChar);
              var uniCh = applyModifierToAscii(ch, [modifier]);
              text += uniCh;
            }
          }
        }
      } else {
        /** @type {string} */
        var applyFullModifiers;
        if (remove) {
          if (range.modifiers.indexOf(modifier)<0) {
            // formatted, but not with this modifier â€” not removing anything
            text += range.uni;
            continue;
          } else if (range.modifiers.length === 1) {
            // last modifier to be removed, simply reduce back to ASCII unformatted
            text += range.ascii;
            continue;
          } else {
            applyFullModifiers = range.modifiers.filter(mod => mod === modifier).join('');
          }
        } else {
          applyFullModifiers = range.modifiers.concat([modifier]).sort().join('');
        }

        var formattedCh = applyModifierToAscii(range.ascii, [applyFullModifiers, modifier]);
        text += formattedCh;
      }
    }

    return text;
  }

  /**
   * @param asciiCh {string}
   * @param modifierAndFallbacks {string[]}
   **/
  function applyModifierToAscii(asciiCh, modifierAndFallbacks) {
    for (var iMod = 0; iMod < modifierAndFallbacks.length; iMod++) {
      var mod = modifierAndFallbacks[iMod];
      var rangeMap = variants[mod];
      var uniRange = rangeMap[asciiCh];
      if (uniRange) return uniRange;

      for (var asciiRange in rangeMap) {
        var uniRange = rangeMap[asciiRange];
        if (typeof uniRange === 'string' && asciiCh.charCodeAt(0) >= asciiRange.charCodeAt(0) && asciiCh.charCodeAt(0) <= asciiRange.charCodeAt(1)) {
          // found respective range in modifier entry, pick corresponding Unicode character
          var uniIndex = asciiCh.charCodeAt(0) - asciiRange.charCodeAt(0);
          var uniUnit = uniRange.length / (asciiRange.charCodeAt(1) - asciiRange.charCodeAt(0) + 1);
          return uniRange.slice(uniIndex * uniUnit, (uniIndex + 1) * uniUnit);
        }
      }
    }

    return asciiCh;
  }

  function createParser() {
      /** @typedef {{ uni: string, ascii: string, modifiers: string[], fullModifiers: string }} LookupEntry */

      /** @type {{ [uni: string]: LookupEntry }} */
    var lookup = {};
    /** @type {RegExp} */
    var matchRegex;

    buildLookups();

    return parser;

    function buildLookups() {
      /** @type {LookupEntry[]} */
      var lookupList = [];

      for (var modKind in variants) {
        var rangeMap = variants[modKind];
        if (!rangeMap || typeof rangeMap !== 'object') continue;

        var modifiers = modKind === 'bold' || modKind.indexOf('bold') ? [modKind] : ['bold', modKind.slice(4)];

        for (var rangeDesc in rangeMap) {
          var rangeChars = rangeMap[rangeDesc];
          if (!rangeChars || typeof rangeChars !== 'string') continue;

          var rangeCount = rangeDesc.length === 1 ? 1 : rangeDesc.charCodeAt(1) - rangeDesc.charCodeAt(0) + 1;
          var uniWidth = rangeChars.length / rangeCount;
          for (let i = 0; i < rangeCount; i++) {
            var ascii = String.fromCharCode(rangeDesc.charCodeAt(0) + i);
            var rangeCh = rangeChars.slice(i * uniWidth, (i + 1) * uniWidth);
            var entry = { uni: rangeCh, ascii: ascii, modifiers: modifiers, fullModifiers: modKind };
            lookupList.push(entry);
            lookup[entry.uni] = entry;
          }
        }
      }

      lookupList.sort(function (entry1, entry2) {
        return -(entry1.uni.length - entry2.uni.length);
      });

      matchRegex = new RegExp(lookupList.map(function(entry) { return entry.uni.replace(/[#-.]|[[-^]|[?|{}]/g, '\\$&'); }).join('|'), 'g');
    }

    /**
     * @param text {string}
     * @param options {{ disableCoalescing?: boolean }=}
     **/
    function parser(text, options) {
      var result = /** @type {((LookupEntry & { length: number }) | string)[] & { modifiers: string[], fullModifiers: string } } */([]);
      result.modifiers = [];

      var disableCoalescing = options && options.disableCoalescing;

      var modifierDict = {};

      matchRegex.lastIndex = 0;
      let index = 0;
      while (true) {
        var match = matchRegex.exec(text);
        if (!match) break;

        if (match.index > index) {
          result.push(text.slice(index, match.index));
        }

        var entry = lookup[match[0]];
        var prev = result.length && result[result.length - 1];

        if (!disableCoalescing && prev && typeof prev !== 'string' && prev.fullModifiers === entry.fullModifiers) {
          prev.uni += entry.uni;
          prev.length += entry.uni.length;
          prev.ascii += entry.ascii;
        } else {
          result.push({
            uni: entry.uni,
            ascii: entry.ascii,
            modifiers: entry.modifiers,
            fullModifiers: entry.fullModifiers,
            length: entry.uni.length
          });

          for (var i = 0; i < entry.modifiers.length; i++) {
            var mod = entry.modifiers[i];
            if (!modifierDict[mod]) {
              modifierDict[mod] = true;
              result.modifiers.push(mod);
            }
          }
        }

        index = match.index + match[0].length;
      }

      if (index < text.length) {
        result.push(text.slice(index));
      }

      result.modifiers.sort();
      result.fullModifiers = result.modifiers.join('');

      return result;
    }
  }


  /** @param str {string} */
  function breakIntoChars(str) {
    /** @type {string[]} */
    var arr = [];
    str.replace(REGEX_anychar_unicode, function (ch) {
      arr.push(ch);
      return '';
    });
    return arr;
  }
}
window.onload = ttywtf;
</script>
</body>
</html>
